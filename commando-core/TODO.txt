FEATURES
-auto register actions for commands with spring
-dispatch commands to actions
-filter commands and results
-schedule commands
-predefined common results
-command validation in actions
-Command serialization to XML (extendable)

TODO/IDEAS

V1.0

DONE:
Remove Spring dependency and only add it as new module(s)
-InVmDispatcher
	-Configurable executor. Prepare also to ForkJoinPool
-SpringInVmDispatcher (autowired, transactional)
-Rest HTTP dispatcher
	-Servlet 3 async
	-URL is command specific
		-@Path annotation (jaxrs) is used on commands to modify url
-Jms dispatcher
	-Implement as remote dispatcher and receiver
	-configurable message format
Timeout support
	-All dispatchers should have timeout. Remotes delegates timeouts to the endpoint and protocoll specific timeout are used like Jms ttl.
	-The executor thread should be recycled on timeout, to prevent hanging threads.
Retry filter with retry policy
Circuit breaker filter
Switch to Observable from ResultFuture
	-Be able to register the callback into the ResultObservable instead of the DispatcherCallback. Before is not needed since the command is fully prepared by the caller.
	-The ObserverResult implementation is extendable to support later reactive or nio execution

TODO:
Service registry
Load balancer dispatcher (uses an LB strategy to delegate to dispatcher instances)
Cache support
	-Implement as a DispatcherFilter
	-Remote uses headers
	-Local cache? No headers
	-Cache invalidation support. (invalidation header. cache always comes with key)
-Load balancer dispatcher (uses an LB strategy to delegate to dispatcher instances)

Other Filters
	-Default result in case of error
	-Logging
	-Monitoring (Command/Result logging, action execution time, jmx support)

Unit and system test coverage

V1.1
Filters
	-DoS protection
	-Priority? (The queue for executor could be a priority queue)
	-Chunk streams?

Dynamic scaling. 
	-Start of an instance automatically get load
	-Stop of an instance is handled by LB (retry should go to another node)
	-Service registry. Lb uses registry.

v1.2
Spring security integration
	Run as 
	Run as async (support for current user and other user too)
	RolesAllowed

V?.?

Action chaining concept. Should we allow this? A result of an action could be a CommandResult which contains the new command or we could use converters like in Camel.

Transaction usecases
-Run each command in separate transaction
-Run multiple commands in one transaction
-Run multiple in the same but one should commit anyhow (example: audit logging)

Command factory pattern for creating commands from different inputs (like rest parameters or camel message)

Akka integration

Camel integration
	-Camel dispatcher components. 
	-Command in the message body
	-Result could go to body or to header or just drop
	-Converter to make command from other types


Bulk dispatcher


Example implementation:
Rest interface
Jms, async and sync dispathing
Caching
Transaction handling (with error audit)



